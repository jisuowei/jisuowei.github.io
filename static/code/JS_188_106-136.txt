<pre><code class="js hljs ">
<span class="hljs-comment">/*

    JavaScript 编写高质量代码：改善JavaScript程序的188个建议 【成林】

    2017-02-22
    ~
    2017-02-24 Noted by Chisw

*/</span>


<span class="hljs-number">106.</span>建议先检测浏览器对 DOM 支持程度
<span class="hljs-number">107.</span>应理清 HTML DOM 加载流程
<span class="hljs-number">108.</span>谨慎访问DOM
<span class="hljs-number">109.</span>比较innerHTML与标准DOM方法
<span class="hljs-number">110.</span>警惕文档遍历中的空格Bug
<span class="hljs-number">111.</span>克隆节点比创建节点更好
<span class="hljs-number">112.</span>谨慎使用HTML集合
<span class="hljs-number">113.</span>用局部变量访问集合元素
<span class="hljs-number">114.</span>使用nextSibling抓取DOM
<span class="hljs-number">115.</span>实现DOM原型继承机制
<span class="hljs-number">116.</span>推荐使用CSS选择器
<span class="hljs-number">117.</span>减少DOM重绘和重排版次数
<span class="hljs-number">118.</span>使用DOM结构树托管事件
<span class="hljs-number">119.</span>使用定时器优化UI队列
<span class="hljs-number">120.</span>使用定时器分解任务
<span class="hljs-number">121.</span>使用定时器限时运行代码
<span class="hljs-number">122.</span>推荐网页工人线程
<span class="hljs-number">123.</span>比较IE和W3C事件流
<span class="hljs-number">124.</span>设计鼠标拖放方案
<span class="hljs-number">125.</span>设计鼠标指针定位方案
<span class="hljs-number">126.</span>小心在元素内定位鼠标指针
<span class="hljs-number">127.</span>妥善使用DOMContentLoaded事件
<span class="hljs-number">128.</span>推荐使用beforeunload事件
<span class="hljs-number">129.</span>自定义事件
<span class="hljs-number">130.</span>从CSS样式表中抽取元素尺寸
<span class="hljs-number">131.</span>慎重使用offsetWidth和offsetHeight
<span class="hljs-number">132.</span>正确计算区域大小
<span class="hljs-number">133.</span>谨慎计算滚动区域大小
<span class="hljs-number">134.</span>避免计算窗口大小
<span class="hljs-number">135.</span>正确获取绝对位置
<span class="hljs-number">136.</span>正确获取相对位置


<span class="hljs-comment">// 2017-02-22</span>
<span class="hljs-number">106.</span>建议先检测浏览器对 DOM 支持程度
<span class="hljs-comment">// DOM 是一个独立于 JS 语言的、使用 XML HTML 文档操作的应用程序接口</span>
<span class="hljs-comment">// 虽然 DOM 是与语言无关的 API，但在浏览器中却是以 JS 实现的</span>
<span class="hljs-comment">// 浏览器通常要求 DOM 实现和 JS 实现保持相互独立（IE中分为：jscript.dll mshtml.dll）</span>

<span class="hljs-comment">// 这种分离技术为其它技术和语言提供了接入接口：</span>
<span class="hljs-comment">// Safari 使用 Webkit 的 WebCore 处理 DOM 和渲染，有分离的 JavascriptCore 引擎</span>
<span class="hljs-comment">// Chrome 也用 Webkit 的 WebCore 库渲染页面，却实现了自己的 JS V8 引擎</span>
<span class="hljs-comment">// Firefox 用 Gecko 渲染引擎，JS 实现采用 Spider-Monkey</span>

<span class="hljs-comment">// 对 DOM 操作的代价很高，富网页应用中尤为显著，两个独立的部分以功能接口链接带来性能损耗</span>

<span class="hljs-comment">// W3C 指定的 DOM 规范包括多个版本，不同版本（级别）还包含不同的子规范和模块，各浏览器千差万别</span>

<span class="hljs-comment">// DOM 0</span>
    <span class="hljs-comment">// W3C 推出 DOM 标准前市场已经流行了几个版本不一致的 DHTML 规范（主要是IE、Netscope）</span>
    <span class="hljs-comment">// 此 DHTML 规定了一套文档对象、集合、方法、属性</span>
    <span class="hljs-comment">// 各版本存在差异，但基本思路和用法还是有章可循（事件处理函数、脚本化样式、文档基本结构对象等）</span>

<span class="hljs-comment">// DOM 1</span>
    <span class="hljs-comment">// 由 W3C 在 1998.10 推出，主要包括两个子规范：</span>
        <span class="hljs-comment">// DOM Core：将 XML 设计为树形节点结构，并为其制定标准，定义创建、编辑、操纵其的属性和方法</span>
        <span class="hljs-comment">// DOM HTML：针对 HTML 文档、标签集合，个别 HTML 标签相关元素定义对象、属性、方法</span>

<span class="hljs-comment">// DOM 2</span>
    <span class="hljs-comment">// 2000.11，发布更新后的 DOM 核心部分，添加了一些新的规范</span>
    <span class="hljs-comment">// 2003.1 ，W3C又正式发布了对DOMHTML子规范的修订，</span>
    <span class="hljs-comment">// 添加了针对 HTML 4.01 和 XHTML 1.0 版本文档中的很多对象、属性和方法</span>
    <span class="hljs-comment">// W3C 把新修订的 DOM 规范统称为 DOM 2.0 推荐版本 主要包括6个推荐子规范：</span>
        <span class="hljs-comment">// DOM2 Core：继承于 DOM Core 子规范，规定 DOM 结构模型，添加更多特性（针对命名空间的方法等）</span>
        <span class="hljs-comment">// DOM2 HTML：继承于 DOM HTML，系统规定了针对 HTML 的文档结构模型，并添加了一些属性</span>
        <span class="hljs-comment">// DOM2 Events：规定鼠标相关的事件（目标、捕获、冒泡、取消）的控制机制，但不包含键盘相关事件</span>
        <span class="hljs-comment">// DOM2 Style（或DOM2 CSS）：提供访问、操纵所有与 CSS 相关的样式及规则的能力</span>
        <span class="hljs-comment">// DOM2 Traversal、DOM2 Range：允许开发者通过迭代方式访问 DOM，按需操作文档</span>
        <span class="hljs-comment">// DOM2 Views：提供访问和更新文档表现的能力</span>
    <span class="hljs-comment">// DOM 2 已成为目前各大浏览器支持的主流标准，但 IE 对于该规范的支持不尽完善，</span>
    <span class="hljs-comment">// 特别是 DOM2 Traversal、DOM2 Range 的支持上</span>

<span class="hljs-comment">// DOM 3</span>
    <span class="hljs-comment">// 2014.4 发布，主要包括以下3个推荐子规范：</span>
        <span class="hljs-comment">// DOM3 Core：继承于 DOM2 Core，并添加更多的方法、属性，同时也修改了一些已有的方法</span>
        <span class="hljs-comment">// DOM3 Load and Save：提供将 XML 内容加载到 DOM 中和将 DOM 序列化为 XML 的能力</span>
        <span class="hljs-comment">// DOM3 Validation：提供确保动态生成的文档的有效性的能力，即如何符合文档类型声明</span>

<span class="hljs-comment">// 为检测各浏览器、各版本对 DOM 支持程度，可调用 DOM 核心规范规定的 document.implementation 对象</span>
<span class="hljs-comment">// 通过此对象的 hasFeature() 来检测浏览器是否支持 DOM 某个特性</span>
    <span class="hljs-keyword">var</span> dom = <span class="hljs-string">'HTML'</span>;  <span class="hljs-comment">// 模块</span>
    <span class="hljs-keyword">var</span> ver = <span class="hljs-string">'1.0'</span>;  <span class="hljs-comment">// 级别</span>
    <span class="hljs-keyword">if</span>(document.implementation) {
        <span class="hljs-keyword">if</span>( document.implementation.hasFeature(dom, ver) ) {
            <span class="hljs-comment">// 支持 dom + ver</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 不支持 dom + ver</span>
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 不支持 implementation 对象</span>
    }

<span class="hljs-comment">// 如果不存在 document.implementation，那基本可以确定它不支持 DOM，</span>
<span class="hljs-comment">// 也可能部分支持，如 IE 6.0 支持HTML，而不支持 Core</span>
<span class="hljs-comment">// 但为了支持 HTML，自然会支持 DOM 核心的某些部分，因为HTML需要核心方法</span>

<span class="hljs-comment">// hasFeature() 包含两个参数，参一指定模块名称，参二指定模块级别</span>
<span class="hljs-comment">// 包括 1、2、3，所有参数都以字符串的形式进行传递</span>

<span class="hljs-comment">// http://www.w3.org/2003/02/06-dom-sup-port.html</span>
<span class="hljs-comment">// 页面会自动显示当前浏览器版本所支持的模块，</span>
<span class="hljs-comment">// 其中“N/A”表示某个模块在某个级别下是不适用的，即还没有开发或推荐标准</span>
<span class="hljs-comment">// 如果显示白色背景，提示信息为“supported”，则表示支持这个级别的模块</span>
<span class="hljs-comment">// 如果显示红色背景，提示这个级别版本的发布时间，则说明当前浏览器版本不支持这个模块</span>

<span class="hljs-comment">// http://www.w3.org/DOM/Test/</span>
<span class="hljs-comment">// 对 DOM 规范中每一个模块的个别部分进行更具体的测试</span>
<span class="hljs-comment">// 这种测试的时间稍长，但会检测每个对象的每个方法，因而可以检测出哪些方法符合规范</span>


<span class="hljs-number">107.</span>应理清 HTML DOM 加载流程
<span class="hljs-comment">// 1.解析HTML结构</span>
<span class="hljs-comment">// 2.加载外部脚本和样式表文件</span>
<span class="hljs-comment">// 3.解析并执行脚本代码</span>
<span class="hljs-comment">// 4.构造HTML DOM 模型</span>
<span class="hljs-comment">// 5.加载图片等外部文件</span>
<span class="hljs-comment">// 6.页面加载完毕</span>

<span class="hljs-comment">// 网页头部的脚本（外部文件）会在构造 HTML DOM 文档结构之前执行，导致执行脚本无法访问文档结构模型</span>
<span class="hljs-comment">// 所以，一般可执行脚本都放在页面初始化事件处理函数中，够确保完全加载完文档之后再执行脚本</span>

<span class="hljs-comment">// 但如果页面包含很多外部文件（大量图片、视频、音频、动画等）可能会延迟脚本的执行时间</span>
<span class="hljs-comment">// 为了避免 JS 脚本处于较长时间的等待，可以把需要执行的脚本分块放在HTML文档结构中间</span>

<span class="hljs-comment">// 这样虽然能够提前执行脚本，但不能保证脚本可以访问该位置后面的文档结构，因为文档结构还没有被构造</span>
<span class="hljs-comment">// 如果在页面最后一个元素之前嵌入脚本，就可以最早执行脚本，并能确保脚本可以访问 HTML 中所有元素</span>

<span class="hljs-comment">// 上述方法容易破坏文档结构，使整个文档看起来很混乱，不利管理</span>
<span class="hljs-comment">// 可以利用一种间接的方法来实现文档结构的有序显示，</span>
<span class="hljs-comment">// 当加载完 DOM 后，也意味着 Document 的属性加载完毕，</span>
<span class="hljs-comment">// 这样可以判断 Document 对象的几个重要方法，如果存在了，则说明 DOM 已经加载完毕</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">if</span>(
            document &amp;&amp; 
            document.getElementsByTagName &amp;&amp; 
            document.getElementById &amp;&amp; 
            document.body
            ) {
            clearInterval(timer);
            <span class="hljs-comment">// JS..</span>
        }
    }
    <span class="hljs-keyword">var</span> timer = setInterval(f, <span class="hljs-number">10</span>);

<span class="hljs-comment">// 先判断 Document 的几个重要方法是否加载完毕，完毕说明 DOM 结构已经完成加载，执行预定的 JS</span>
<span class="hljs-comment">// 为了能够实时跟踪加载过程，一个定时器不断调用 f()，以便快速、准确地判断DOM加载状态</span>


<span class="hljs-number">108.</span>谨慎访问DOM
<span class="hljs-comment">// DOM 元素的访问代价较高，修改代价更高（浏览器重新计算页面的几何变化）</span>
<span class="hljs-comment">// 尽量减少 DOM 的访问，并保持在 ECMAScript 范围内缓存 DOM 引用</span>

<span class="hljs-comment">// 最坏的情况是使用循环执行此操作，特别是在 HTML 集合中使用循环</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerHTMLLoop</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) {
            document.getElementById(<span class="hljs-string">'here'</span>).innerHTML += <span class="hljs-string">'a'</span>;
        }
    }

<span class="hljs-comment">// 高效的写法</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerHTMLLoop</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> content = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) {
            content += <span class="hljs-string">'a'</span>;
        }
        document.getElementById(<span class="hljs-string">'here'</span>).innerHTML += content;
    }


<span class="hljs-number">109.</span>比较innerHTML与标准DOM方法
<span class="hljs-comment">// 更新页面时，是使用不标准的 innerHTML，还是使用纯 DOM 方法（如document.cre-ateElement()）</span>
<span class="hljs-comment">// 如果不考虑标准问题，两者性能基本相近，不过在几乎所有浏览器中，innerHTML 速度更快一些</span>
<span class="hljs-comment">// 但最新的基于 WebKit 的浏览器除外（Chrome、Safari）</span>

<span class="hljs-comment">// innerHTML 的好处在早期的浏览器上是显而易见的（在IE 6中使用 innerHTML 要比 DOM 快三四倍）</span>
<span class="hljs-comment">// 但在最新版本的浏览器上就不那么明显了</span>
<span class="hljs-comment">// 而在最新的基于WebKit的浏览器上结果正好相反，使用 DOM 更快</span>

<span class="hljs-comment">// 要在一个性能苛刻的操作中更新一大块 HTML 页面，innerHTML 在大多数浏览器中执行得更快</span>
<span class="hljs-comment">// 对于大多数日常操作而言，两者差异不大</span>
<span class="hljs-comment">// 应当综合用户经常使用的浏览器、代码可读性、可维护性、团队习惯，以及代码风格来决定</span>


<span class="hljs-number">110.</span>警惕文档遍历中的空格Bug
<span class="hljs-comment">// 遍历 DOM 文档元素时，空格的存在很容易造成误解，因为DOM把空格、换行符也作为一个节点进行解析</span>
    <span class="hljs-keyword">var</span> e = document.documentElement.lastChild.firstChild.nodeName;

<span class="hljs-comment">// 在文档结构加载完毕之后调用该函数清除所有仅包含空格的文本节点</span>
    <span class="hljs-comment">// 清除指定元素及其所有子元素之间的空格，参数：指定要清除空格的起始节点</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clean</span><span class="hljs-params">(e)</span> {</span>
        <span class="hljs-keyword">var</span> e = e || document;
        <span class="hljs-keyword">var</span> f = e.firstChild;
        <span class="hljs-keyword">while</span>(f != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span>(f.nodeType == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-regexp">/\s/</span>.test(f.nodeValue)) {
                e.removeChild(f);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f.nodeType == <span class="hljs-number">1</span>) {
                argument.callee(f);
            }
            f = f.nextSibling;
        }
    }

<span class="hljs-comment">// 在准备遍历 DOM 时，可以先调用这个功能函数清除所有元素之间的空格，然后再遍历文档</span>
<span class="hljs-comment">// 实现兼容，并让准确定位节点位置变得更容易，且不会对渲染产生副作用</span>

<span class="hljs-comment">// 注意：仅是临时性地清除，每一次加载时都要重新执行一遍清除操作</span>
<span class="hljs-comment">// 虽然高效，但是每次都需要先执行一次遍历，如果结构比较庞杂，那么这个操作消耗的系统资源是不可小视的</span>
<span class="hljs-comment">// 应该尝试使用其他途径来定位节点，不可轻易地使用这种比较原始的方法</span>


<span class="hljs-number">111.</span>克隆节点比创建节点更好
<span class="hljs-comment">// 使用 DOM 方法更新页面内容的另一个途径是克隆已有 DOM元 素，而不是创建新的元素</span>
<span class="hljs-comment">// 也就是使用 element.cloneNode()（element是一个已存在的节点）代替document.createElement()</span>
<span class="hljs-comment">// 多数浏览器上，克隆更有效率，但不太多</span>
<span class="hljs-comment">// 用克隆节点的办法创建 1000 行表格，只创建一次单元格，然后重复执行复制操作，这样会快一些</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tableClonedDOM</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> i, table, thead, tbody, tr, th, td, a, ul, li,
            oth = document.createElement(<span class="hljs-string">'th'</span>),
            otd = document.createElement(<span class="hljs-string">'td'</span>),
            otr = document.createElement(<span class="hljs-string">'tr'</span>),
            oa = document.createElement(<span class="hljs-string">'a'</span>),
            oli = document.createElement(<span class="hljs-string">'li'</span>),
            oul = document.createElement(<span class="hljs-string">'ul'</span>);
        tbody = document.createElement(<span class="hljs-string">'tbody'</span>);
        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">1000</span>; i++) {
            tr = otr.cloneNode(<span class="hljs-literal">false</span>);
            td = otd.cloneNode(<span class="hljs-literal">false</span>);
            td.appendChild(document.createTextNode((i % <span class="hljs-number">2</span>) ? <span class="hljs-string">'yes'</span> : <span class="hljs-string">'no'</span>));
            tr.appendChild(td);
            td = otd.cloneNode(<span class="hljs-literal">false</span>);
            td.appendChild(document.createTextNode(i));
            tr.appendChild(td);
            td = otd.cloneNode(<span class="hljs-literal">false</span>);
            td.appendChild(document.createTextNode(<span class="hljs-string">'my name is #'</span> + i));
            tr.appendChild(td);
            <span class="hljs-comment">// ..</span>
        }
        <span class="hljs-comment">// ..</span>
    }


<span class="hljs-number">112.</span>谨慎使用HTML集合
<span class="hljs-comment">// HTML 集合是用于存放 DOM 节点引用的类数组对象</span>
<span class="hljs-comment">// 下列方法的返回值都是一个集合：   </span>
    document.getElementsByName()
    document.getElementsByClassName()
    document.getElementsByTagName_r()

<span class="hljs-comment">// 下列属性也属于 HTML 集合：   </span>
    document.images  <span class="hljs-comment">// 页面中所有的&lt;img&gt;元素</span>
    document.links  <span class="hljs-comment">// 所有的&lt;a&gt;元素</span>
    document.forms  <span class="hljs-comment">// 所有表单</span>
    document.forms[<span class="hljs-number">0</span>].elements  <span class="hljs-comment">// 页面中第一个表单的所有字段</span>

<span class="hljs-comment">// 这些方法和属性返回 HTMLCollection 对象，是一种类似数组的列表</span>
<span class="hljs-comment">// 它不是数组，因为它没有数组的方法，比如push()、slice()等</span>
<span class="hljs-comment">// 但它提供了一个 length 属性，与数组一样可以使用索引访问列表中的元素</span>
<span class="hljs-comment">// 正如 DOM 标准中所定义的，HTML 集合是一个虚拟存在，当底层文档更新时它将自动更新</span>
<span class="hljs-comment">// HTML 集合实际上在查询文档，当更新信息时，每次都要重复执行这种查询操作</span>
<span class="hljs-comment">// 例如读取集合中元素的数目，也就是 length，这正是执行低效率的原因</span>

    <span class="hljs-keyword">var</span> alldivs = document.getElementsByTagName_r(<span class="hljs-string">'div'</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; alldivs.length; i++) {
        document.body.appendChild(document.createElement(<span class="hljs-string">'div'</span>))
    }

<span class="hljs-comment">// 这段代码看上去只是简单地增加 div 的数量：遍历现有 div，每次创建一个新的并附加上</span>
<span class="hljs-comment">// 这是个死循环，循环终止条件 alldivs.length 在每次迭代中都会增加，它反映出底层文档的当前状态</span>

<span class="hljs-comment">// 这样遍历 HTML 集合会导致逻辑错误且很慢，因为每次迭代都需要进行查询</span>
<span class="hljs-comment">// 所以不建议用数组的 length 做循环判断条件</span>
<span class="hljs-comment">// 访问集合的length比数组的length还要慢，因为这意味着每次都要重新运行查询过程</span>

<span class="hljs-comment">// 下例中，将一个集合 coll 复制到数组 arr 中，然后比较每次迭代所用的时间</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span><span class="hljs-params">(coll)</span> {</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, a=[], len=coll.length; i&lt;len; i++) {
            a[i] = coll[i];
        }
        <span class="hljs-keyword">return</span> a;
    }

    <span class="hljs-keyword">var</span> coll = document.getElementsByTagName_r(<span class="hljs-string">'div'</span>);
    <span class="hljs-keyword">var</span> arr = toArray(coll);

<span class="hljs-comment">// 比较慢</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loopCollection</span><span class="hljs-params">()</span> {</span> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>; count &lt; coll.length; count++) {} }

<span class="hljs-comment">// 比较快</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loopCopiedArray</span><span class="hljs-params">()</span> {</span> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>; count &lt; arr.length; count++) {} }

<span class="hljs-comment">// 当每次迭代过程访问集合的 length 时，将会导致集合器更新，在所有浏览器上都会产生明显的性能损失</span>
<span class="hljs-comment">// 优化：只要将集合的 length 缓存到一个变量中，然后在循环判断条件中使用这个变量</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loopCacheLengthCollection</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> coll = document.getElementsByTagName_r(<span class="hljs-string">'div'</span>),
        len = coll.length;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>; count &lt; len; count++) {}
    }

<span class="hljs-comment">// 上面函数的运行速度与 loopCopiedArray() 一样快</span>
<span class="hljs-comment">// 遍历数组比遍历集合快，如果先将集合元素复制到数组，访问它们的属性将更快</span>
<span class="hljs-comment">// 记住：这需要一个额外的步骤——遍历集合，因此，应当评估在特定条件下使用这样一个数组副本是否有益</span>


<span class="hljs-number">113.</span>用局部变量访问集合元素
<span class="hljs-comment">// 一般访问任何类型的 DOM，当同一个属性或方法被访问一次以上时，最好使用一个局部变量缓存该 DOM 成员</span>
<span class="hljs-comment">// 当遍历一个集合时，第一个要优化的是将集合引用存储于局部变量，并在循环之外缓存 length 属性</span>
<span class="hljs-comment">// 然后，如果在循环体中多次访问同一个集合元素，那么使用局部变量缓存它</span>

<span class="hljs-comment">// 在下面示例中，循环访问每个元素的3个属性：</span>
<span class="hljs-comment">// 执行最慢的方法是每次都要访问全局变量 document</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectionGlobal</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> coll = document.getElementsByTagName_r(<span class="hljs-string">'div'</span>),
            len = coll.length, name = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>; count &lt; len; count++) {
            name = document.getElementsByTagName_r(<span class="hljs-string">'div'</span>)[count].nodeName;
            name = document.getElementsByTagName_r(<span class="hljs-string">'div'</span>)[count].nodeType;
            name = document.getElementsByTagName_r(<span class="hljs-string">'div'</span>)[count].tagName;
        }
        <span class="hljs-keyword">return</span> name;
    };

<span class="hljs-comment">// 优化后的代码缓存了一个指向集合的引用</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectionLocal</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> coll = document.getElementsByTagName_r(<span class="hljs-string">'div'</span>),
            len = coll.length, name = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>; count &lt; len; count++) {
            name = coll[count].nodeName;
            name = coll[count].nodeType;
            name = coll[count].tagName;
        }
        <span class="hljs-keyword">return</span> name;
    };

<span class="hljs-comment">// 执行最快的方法是将集合的当前元素存入局部变量</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectionNodesLocal</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> coll = document.getElementsByTagName_r(<span class="hljs-string">'div'</span>),
            len = coll.length, name = <span class="hljs-string">''</span>, el = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>; count &lt; len; count++) {
            el = coll[count];
            name = el.nodeName;
            name = el.nodeType;
            name = el.tagName;
        }
        <span class="hljs-keyword">return</span> name;
    };


<span class="hljs-number">114.</span>使用nextSibling抓取DOM
<span class="hljs-comment">// DOM 提供了多重途径访问整个文档结构的特定部分，应当酌情选用</span>
<span class="hljs-comment">// 经常遇到根据一个 DOM 元素操作其它元素的情况</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testNextSibling</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> e1 = document.getElementById(<span class="hljs-string">'div'</span>),
            ch = e1.firstChild, name = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">do</span> {
            name = ch.nodeName;
        } <span class="hljs-keyword">while</span> (ch == ch.nextSibling);
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testChildNodes</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> e1 = document.getElementById(<span class="hljs-string">'div'</span>),
            ch = e1.firstChild, len = ch.length, name = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;len; i++) {
            name = ch[i].nodeName;
        }
        <span class="hljs-keyword">return</span> name;
    }

<span class="hljs-comment">// 上面两个功能相同的函数都采用非递归方式遍历一个元素的子节点</span>
<span class="hljs-comment">// childNodes 是一个集合，小心，在循环中缓存 length 属性，避免每次迭代中更新length的值</span>
<span class="hljs-comment">// 各浏览器上两种函数的运行时间基本相等，但在 IE 中，nextSibling 比 childNodes 好</span>
<span class="hljs-comment">// IE6 中快16倍，IE7 中快105倍，鉴此，旧版 IE 性能严苛条件下，首选 nextSibling</span>


<span class="hljs-number">115.</span>实现DOM原型继承机制
<span class="hljs-comment">// 符合 DOM 标准的浏览器都支持 HTMLElement 类，DOM 中所有元素都继承于此类</span>
<span class="hljs-comment">// 而 HTMLElement 又继承于 Element 类，Element 类继承于 Node 类</span>
<span class="hljs-comment">// 通过在 HTMLElement 类的原型对象上定义方法，就可以为所有元素绑定函数和数据</span>
    HTMLElement.prototype.pre = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> e = <span class="hljs-keyword">this</span>.previousSibling;
        <span class="hljs-keyword">while</span> (e &amp;&amp; e.nodeType != <span class="hljs-number">1</span>) {
            e = e.previousSibling;
        }
        <span class="hljs-keyword">return</span> e;
    }

    <span class="hljs-comment">// 注意：在函数体内部应该通过 this 来执行当前元素对象，而非参数形式</span>

    <span class="hljs-comment">// 应用此原型方法：</span>
    window.onload = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> e = document.getElementsByTagName(<span class="hljs-string">'div'</span>)[<span class="hljs-number">0</span>];
        e = e.pre();
        alert(e.nodeName);
    }

<span class="hljs-comment">// 通过原型可以很方便的扩展每个元素的方法或属性，但万恶的IE隐藏了这个类，禁止了 JS 访问</span>
<span class="hljs-comment">// 兼容方法：</span>
    <span class="hljs-keyword">var</span> DOMElement = {
        extend: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, fn)</span> {</span>
            <span class="hljs-comment">// 添加名称为 name 的 fn</span>
            <span class="hljs-keyword">if</span>(!document.all) {
                <span class="hljs-built_in">eval</span>(<span class="hljs-string">'HTMLElement.prototype.'</span>+ name +<span class="hljs-string">'='</span>+ fn);
            } <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// IE 中必须重写下面的函数</span>
                <span class="hljs-keyword">var</span> _createElement = document.createElement;
                document.createElement = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(tag)</span> {</span>
                    <span class="hljs-keyword">var</span> _elem = _createElement(tag);
                    <span class="hljs-built_in">eval</span>(<span class="hljs-string">'_elem.'</span>+ name +<span class="hljs-string">'='</span>+ fn);
                    <span class="hljs-keyword">return</span> _elem;
                }
                <span class="hljs-keyword">var</span> _getElementById = document.getElementById;
                document.getElementById = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(id)</span> {</span>
                    <span class="hljs-keyword">var</span> _elem = _getElementById(id);
                    <span class="hljs-built_in">eval</span>(<span class="hljs-string">'_elem.'</span>+ name +<span class="hljs-string">'='</span>+ fn);
                    <span class="hljs-keyword">return</span> _elem;
                }
                <span class="hljs-keyword">var</span> _getElementsByTagName = document.getElementsByTagName;
                document.getElementsByName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(tag)</span> {</span>
                    <span class="hljs-keyword">var</span> _arr = _getElementsByTagName(tag);
                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> _elem = <span class="hljs-number">0</span>; _elem &lt; arr.length; _elem++) {
                        <span class="hljs-built_in">eval</span>(<span class="hljs-string">'_arr[_elem].'</span>+ name +<span class="hljs-string">'='</span>+ fn);
                        <span class="hljs-keyword">return</span> _arr;
                    }
                }
            }
        }
    }

    <span class="hljs-comment">// 首先利用 Document 对象的 All 对象来判断浏览器类型（只有IE支持）</span>
    <span class="hljs-comment">// 然后借助变量存储原方法的引用，再重写方法，重写过程中先执行原方法</span>
    <span class="hljs-comment">// 接着，动态为当前元素加入一个用户的方法</span>
    <span class="hljs-comment">// 最后再返回原方法执行的值，既不破坏原方法的功能，又为当前元素扩展了新方法</span>
    <span class="hljs-comment">// 应用此方法时应确保在获取或创建元素之前执行它</span>

    <span class="hljs-comment">// 具体应用：</span>
    DOMElement.extend(<span class="hljs-string">'pre'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
        <span class="hljs-keyword">var</span> e = <span class="hljs-keyword">this</span>.previousSibling;
        <span class="hljs-keyword">while</span>(e &amp;&amp; e.nodeType != <span class="hljs-number">1</span>) {
            e = e.previousSibling;
        }
        <span class="hljs-keyword">return</span> e;
    })


<span class="hljs-number">116.</span>推荐使用CSS选择器
<span class="hljs-comment">// childNodes、firstChild 和 nextSibling 不区分元素节点和其他类型节点的（注释节点、文本节点）</span>
<span class="hljs-comment">// 在许多情况下，只有元素节点会被访问，所以在循环中，似乎应当对节点返回类型进行检查，过滤出非元素节点</span>
<span class="hljs-comment">// 事实上，这些检查和过滤都是不必要的 DOM 操作</span>

<span class="hljs-comment">// 许多浏览器提供了只返回元素节点的 API 函数，如可用则利用，这些函数比在 JS 中写过滤函数要快</span>

<span class="hljs-comment">// 遍历 children 比遍历 childNodes 更快，因为集合项更少</span>
<span class="hljs-comment">// HTML 源码中的空格实际上是文本节点，它们不包括在 children集合中</span>
<span class="hljs-comment">// 在所有浏览器中，children 比 childNodes更快，差别不是太大，通常只快1.5～3倍</span>
<span class="hljs-comment">// 特别值得注意的是，在 IE 中，遍历 children 明显快于遍历 childNodes</span>

<span class="hljs-comment">// 选择 DOM 元素经常需要更精细的控制，而不只是采用 getElementById 之类的函数</span>
<span class="hljs-comment">// 有时结合这些函数调用并迭代操作它们返回的节点，以获取所需要的元素，这一精细的过程可能使效率降低</span>

<span class="hljs-comment">// 另外，使用 CSS 选择器是一个便捷的确定节点的方法，这是因为大家已经对CSS很熟悉了</span>
<span class="hljs-comment">// 许多 JS 库为此提供了API，而且最新的浏览器提供了一个名为 querySelectorAll()的原生浏览器DOM函数</span>
<span class="hljs-comment">// 显然这种方法比使用 JS 和 DOM 迭代并缩小元素列表的方法要快</span>
    <span class="hljs-keyword">var</span> elements = document.querySelectorAll(<span class="hljs-string">'#menu a'</span>);

    <span class="hljs-comment">// elements 的值将包含一个引用列表，指向那些具有id="menu"属性的元素</span>
    <span class="hljs-comment">// 函数 querySelectorAll() 接收一个CSS选择器字符串参数并返回一个 NodeList</span>
    <span class="hljs-comment">// 此函数不返回 HTML 集合，这就避免了HTML集合所固有的性能问题，以及潜在的逻辑问题</span>

<span class="hljs-comment">// 如果不使用 docuemnt.querySelectorAll：</span>
    <span class="hljs-keyword">var</span> elements = docuemnt.getElementById(<span class="hljs-string">'menu'</span>)._getElementsByTagName_r(<span class="hljs-string">'a'</span>);

    <span class="hljs-comment">// elements 将是一个 HTML 集合，要想得到与 query.. 同样的返回，需要将它复制到一个数组中</span>

<span class="hljs-comment">// DOM 元素亦可使用：</span>
    elref.querySelectorAll(<span class="hljs-string">'selector'</span>);


<span class="hljs-number">117.</span>减少DOM重绘和重排版次数
<span class="hljs-comment">// 浏览器在完成所有页面 HTML、JS、CSS、图片下载后，将解析文件并创建两个内部数据结构：  </span>
    <span class="hljs-comment">// 一棵DOM树：表示页面结构</span>
    <span class="hljs-comment">// 一棵渲染树：表示DOM节点如何显示</span>

<span class="hljs-comment">// 在渲染树中为每个需要显示的 DOM 树节点存放至少一个节点（隐藏的DOM元素在渲染树中没有对应节点）</span>
<span class="hljs-comment">// 将渲染树上的节点称为框（盒），符合 CSS 模型的定义，将页面元素看做一个具有填充、边距、边框和位置的盒</span>
<span class="hljs-comment">// 一旦 DOM 树和渲染树构造完毕，浏览器就可以显示（绘制）页面上的元素了</span>

<span class="hljs-comment">// 当 DOM 改变影响到元素的几何属性（宽和高）时，将发生一系列后续动作，</span>
<span class="hljs-comment">// 浏览器需要重新计算元素的几何属性，且其他元素的几何属性和位置也会因此改变并受到影响</span>
<span class="hljs-comment">// 浏览器使渲染树上受到影响的部分失效，然后重构渲染树，这个过程称做重排版</span>
<span class="hljs-comment">// 当重排版完成时，浏览器会在一个重绘进程中重新绘制屏幕上受影响的部分</span>

<span class="hljs-comment">// 不是所有的改变都会影响几何属性：改变背景色，只需重绘，不需重排版，因为元素的布局没有改变</span>

<span class="hljs-comment">// 重绘和重排版是负担很重的操作，可能导致网页应用的用户界面失去响应，应尽可能减少此操作</span>

<span class="hljs-comment">// 重排版情况：</span>
    <span class="hljs-comment">// 添加、删除可见 DOM 元素</span>
    <span class="hljs-comment">// 元素位置改变</span>
    <span class="hljs-comment">// 元素尺寸改变：边距、填充、边框宽度、宽度、高度等）</span>
    <span class="hljs-comment">// 内容改变：文本改变、图片被另一个不同尺寸的图片所替代</span>
    <span class="hljs-comment">// 最初的页面渲染</span>
    <span class="hljs-comment">// 浏览器窗口尺寸改变</span>

<span class="hljs-comment">// 根据改变的性质，渲染树上或大或小的一部分需要重新计算</span>
<span class="hljs-comment">// 某些改变可能导致重排版整个页面，如当一个滚动条出现时</span>

<span class="hljs-comment">// 因为计算量与每次重排版有关，因此大多数浏览器都通过队列化修改和批量显示来优化重排版过程</span>
<span class="hljs-comment">// 然而，可能经常不由自主地强迫队列进行刷新并要求立刻应用所有计划改变的部分</span>
<span class="hljs-comment">// 获取布局信息的操作将导致刷新队列动作，这意味着使用了下面这些方法：   </span>
    <span class="hljs-comment">// offsetTop、offsetLeft、offsetWidth、off-setHeight</span>
    <span class="hljs-comment">// scrollTop、scrollLeft、scrollWidth、scroll-Height</span>
    <span class="hljs-comment">// clientTop、clientLeft、clientWidth、clien-tHeight</span>
    <span class="hljs-comment">// getComputedStyle() 在IE中此函数称为 currentStyle</span>

<span class="hljs-comment">// 布局信息是由这些方法返回最新的数据，浏览器不得不运行渲染队列中待改变的项目并重新排版以返回正确的值</span>
<span class="hljs-comment">// 在改变样式的过程中，最好不要使用前面列出的那些属性</span>
<span class="hljs-comment">// 任何一个访问都将刷新渲染队列，即使正在获取那些最近未发生改变的或与最新的改变无关的布局信息</span>
    <span class="hljs-keyword">var</span> computed, tmp = <span class="hljs-string">''</span>,
        bodystyle = document.body.style;
    <span class="hljs-keyword">if</span>(document.body.currentStyle) { <span class="hljs-comment">// IE, Opera</span>
        computed = document.body.currentStyle;
    } <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// W3C</span>
        computed = document.defaultView.getComputedStyle(document.body, <span class="hljs-string">''</span>);
    }
    bodystyle.color = <span class="hljs-string">'red'</span>;
    tmp = computed.backgroundColor;
    bodystyle.color = <span class="hljs-string">'white'</span>;
    tmp = computed.backgroundImage;
    bodystyle.color = <span class="hljs-string">'green'</span>;
    tmp = computed.backgroundAttachment;

<span class="hljs-comment">// 在上面代码中，body元素的前景色被改变了3次，在每次改变之后都导入了 computed 的风格</span>
<span class="hljs-comment">// 导入的属性 backgroundColor、backgroundImage、backgroundAttachment 与颜色改变无关</span>
<span class="hljs-comment">// 然而，浏览器需要刷新渲染队列并重排版，因为 computed 的风格是被查询而引发的</span>

<span class="hljs-comment">// 更好的方法是不要在布局信息改变时查询 computed 风格</span>
<span class="hljs-comment">// 如果将查询 computed 风格的代码移到末尾，那么在所有浏览器上都会执行得更快</span>
    bodystyle.color = <span class="hljs-string">'red'</span>;
    bodystyle.color = <span class="hljs-string">'white'</span>;
    bodystyle.color = <span class="hljs-string">'green'</span>;
    tmp = computed.backgroundColor;
    tmp = computed.backgroundImage;
    tmp = computed.backgroundAttachment;

<span class="hljs-comment">// 由于重排版和重绘代价较高，因此，提高程序响应速度的一个好策略是减少此类操作发生的机会</span>
<span class="hljs-comment">// 为减少发生次数，应该将多个 DOM 和风格改变后合并到一个批次中一次性执行</span>
    <span class="hljs-keyword">var</span> el = document.getElementById(<span class="hljs-string">'mydiv'</span>);
    el.style.borderLeft = <span class="hljs-string">'1px'</span>;
    el.style.borderRight = <span class="hljs-string">'2px'</span>;
    el.style.padding = <span class="hljs-string">'5px'</span>;

<span class="hljs-comment">// 上面代码中改变了3个样式属性，每次都影响到几何属性，导致重排版了3次</span>
<span class="hljs-comment">// 目前大多数浏览器都优化了这种情况，只进行一次重排版，但在旧版本浏览器中，效率将十分低下</span>
<span class="hljs-comment">// 如果其他代码在这段代码运行时查询布局信息，将导致3次重布局发生</span>
<span class="hljs-comment">// 而且，此代码访问 DOM 4次，可以被优化</span>

<span class="hljs-comment">// 实现相同效果但效率更高的方法：将所有改变合并在一起执行，只修改 DOM 一次</span>
    <span class="hljs-keyword">var</span> el = document.getElementById(<span class="hljs-string">'mydiv'</span>);
    el.style.cssText = <span class="hljs-string">'border-left: 1px; border-right: 2px; padding: 5px;'</span>;

    <span class="hljs-comment">// 在这个示例中，修改 cssText 属性，覆盖已存在的风格信息</span>
    <span class="hljs-comment">// 如果打算保持当前的风格，那么可以将它附加在cssText字符串的后面</span>
        el.style.cssText += <span class="hljs-string">'; border-left: 1px;'</span>;

<span class="hljs-comment">// 另一个方法是修改 CSS 的类名称，而非修改内联风格代码，适用那些风格不依赖于运行逻辑且不需要计算的情况</span>
<span class="hljs-comment">// 改变后的CSS类名称更清晰，更易于维护，虽然它可能带来轻微的性能冲击，但是有助于保持脚本免除显示代码</span>
    <span class="hljs-keyword">var</span> el = document.getElementById(<span class="hljs-string">'mydiv'</span>);
    el.className = <span class="hljs-string">'active'</span>;

<span class="hljs-comment">// 当需要对 DOM 元素进行多次修改时，可以通过以下步骤减少重绘和重排版的次数</span>
    <span class="hljs-comment">// 1.从文档流中摘除该元素</span>
    <span class="hljs-comment">// 2.对其应用多重改变</span>
    <span class="hljs-comment">// 3.将元素带回文档中</span>

    <span class="hljs-comment">// 此过程引发两次重排版：第1步引发一次，第3步引发一次</span>
    <span class="hljs-comment">// 如果忽略了这两个步骤，那么第2步中每次改变都将引发一次重排版</span>

<span class="hljs-comment">// 经历以下3步后可以将DOM从文档中摘除：</span>
    <span class="hljs-comment">// 1.隐藏元素，进行修改，然后再显示它</span>
    <span class="hljs-comment">// 2.使用一个文档片断在已存 DOM 之外创建一个子树，然后将它复制到文档中</span>
    <span class="hljs-comment">// 3.将原始元素复制到一个脱离文档的节点中，修改副本，然后覆盖原始元素</span>

    <span class="hljs-comment">// 下例中一个链接列表必须被更多的信息所更新：</span>
    <span class="hljs-comment">/*
        &lt;ul id="mylist"&gt;
            &lt;li&gt;&lt;a href="#"&gt;链接1&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href="#"&gt;链接2&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    */</span>
    
    <span class="hljs-comment">// 假设附加数据已经存储在一个对象中了，需要将其插入到这个列表中</span>
        <span class="hljs-keyword">var</span> data = [
            {<span class="hljs-string">"name"</span>: <span class="hljs-string">"链接3"</span>, <span class="hljs-string">"url"</span>: <span class="hljs-string">"#"</span>},
            {<span class="hljs-string">"name"</span>: <span class="hljs-string">"链接4"</span>, <span class="hljs-string">"url"</span>: <span class="hljs-string">"#"</span>}
        ];

    <span class="hljs-comment">// 下面是一个通用的函数，用于将新数据更新到指定节点中：</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendDataToElement</span><span class="hljs-params">(appendToElement, data)</span> {</span>
            <span class="hljs-keyword">var</span> a, li;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, max=data.length; i&lt;max; i++) {
                a = document.createElement(<span class="hljs-string">'a'</span>);
                a.href = data[i].url;
                a.appendChild(document.createTextNode(data[i].name));
                li = document.createElement(<span class="hljs-string">'li'</span>);
                li.appendChild(a);
                appendToElement.appendChild(li);
            }
        };

    <span class="hljs-comment">// 将数据更新到列表而不管重排版问题，最显著的方法如下：</span>
        <span class="hljs-keyword">var</span> ul = document.getElementById(<span class="hljs-string">'mylist'</span>);
        appendDataToElement(ul, data);

<span class="hljs-comment">// 然而，将 data 队列上的每个新条目追加到DOM树都会导致重排版</span>
    <span class="hljs-comment">// 第一种减少重排版的方法：改变display属性，临时从文档上移除&lt;ul&gt;元素然后再恢复它</span>
        <span class="hljs-keyword">var</span> ul = document.getElementById(<span class="hljs-string">'mylist'</span>);
        ul.style.display = <span class="hljs-string">'none'</span>;
        appendDataToElement(ul, data);
        ul.style.display = <span class="hljs-string">'block'</span>;

    <span class="hljs-comment">// 第二种减少重排版的方法：在文档之外创建并更新一个文档片断，然后将它附加在原始列表上</span>
    <span class="hljs-comment">// 文档片断是一个轻量级的 document 对象，它被设计用于更新、移动节点之类的任务</span>
    <span class="hljs-comment">// 文档片断一个便利的语法特性：向节点附加一个片断时实际添加的是文档片断的子节点群，而非文档片断自己</span>
        <span class="hljs-keyword">var</span> fragment = document.createDocumentFragment();
        appendDataToElement(fragment, data);
        document.getElementById(<span class="hljs-string">'mylist'</span>).appendChild(fragment);

    <span class="hljs-comment">// 第三种减少重排版的方法：首先创建要更新节点的副本，然后在副本上操作，最后用新节点覆盖老节点</span>
        <span class="hljs-keyword">var</span> old = document.getElementById(<span class="hljs-string">'mylist'</span>);
        <span class="hljs-keyword">var</span> clone = old.cloneNode(<span class="hljs-literal">true</span>);
        appendDataToElement(clone, data);
        old.parentNode.replaceChild(clone, old);

    <span class="hljs-comment">// 尽可能使用文档片断（第二种方法）来减少重排版，因为它涉及最少数量的DOM操作和重排版</span>
    <span class="hljs-comment">// 唯一潜在的隐患：当前文档片断还没有得到充分利用</span>

<span class="hljs-comment">// 浏览器通过队列化修改和批量运行的方法，尽量减少重排版次数</span>
<span class="hljs-comment">// 当查询布局信息如偏移量、滚动条位置或风格属性时，浏览器刷新队列并执行所有修改操作，以返回最新的数值</span>
<span class="hljs-comment">// 应尽量减少对布局信息的查询，查询时将查询次数赋给局部变量，并通过局部变量参与计算</span>

<span class="hljs-comment">// 例如，将元素 myElement 向右下方向平移，每次一个像素，</span>
<span class="hljs-comment">// 起始于100像素×100像素位置，结束于500像素×500像素位置，在timeout循环体中可以使用</span>
    myElement.style.left = <span class="hljs-number">1</span> + myElement.offsetLeft + <span class="hljs-string">'px'</span>;
    myElement.style.top = <span class="hljs-number">1</span> + myElement.offsetTop + <span class="hljs-string">'px'</span>;
    <span class="hljs-keyword">if</span> (myElement.offsetLeft &gt;= <span class="hljs-number">500</span>) {
        stopAnimation();
    }

    <span class="hljs-comment">// 这样没有效率，每次元素移动，代码查询偏移量，就会导致浏览器刷新渲染队列，并不会从优化中获益</span>

<span class="hljs-comment">// 还有一个办法，只需要获得起始位置值一次，</span>
<span class="hljs-comment">// 将它存入局部变量中（var cur-rent=myElement.offsetLeft;）</span>
<span class="hljs-comment">// 然后在动画循环中使用current变量而不再查询偏移量</span>
    current++;
    myElement.style.left = current + <span class="hljs-string">'px'</span>;
    myElement.style.top = current + <span class="hljs-string">'px'</span>;
    <span class="hljs-keyword">if</span> (current &gt;= <span class="hljs-number">500</span>) {
        stopAnimation();
    }

<span class="hljs-comment">// 重排版有时只影响渲染树的一小部分，但也可能影响很大一部分，甚至整个渲染树</span>
<span class="hljs-comment">// 浏览器需要重排版的部分越小，应用程序的响应速度就越快</span>
<span class="hljs-comment">// 当一个页面顶部的动画推移了差不多整个页面时，将引发巨大的重排版动作，使用户感到动画不流畅</span>
<span class="hljs-comment">// 渲染树的大多数节点需要重新计算，这使情况变得更糟糕</span>

<span class="hljs-comment">// 使用以下步骤可以避免对大部分页面进行重排版：</span>
    <span class="hljs-comment">// 1.使用绝对坐标定位页面动画的元素，使它位于页面布局流之外</span>
    <span class="hljs-comment">// 2.启动元素动画，当它扩大时，将会临时覆盖部分页面</span>
        <span class="hljs-comment">// 这是一个重绘过程，但只影响页面的一小部分，避免重排版及重绘一大块页面</span>
    <span class="hljs-comment">// 3.当动画结束时，重新定位。</span>


<span class="hljs-comment">// 2017-02-23</span>
<span class="hljs-number">118.</span>使用DOM结构树托管事件
<span class="hljs-comment">// 当页面中存在大量元素有一到多个事件句柄连接时可能会影响性能</span>
<span class="hljs-comment">// 每个句柄都有代价：页面标记和JS代码带来的页面负担、运行时间负担、内存</span>

<span class="hljs-comment">// 事件托管：一个简单、优雅的处理 DOM 事件的技术</span>
<span class="hljs-comment">// 事实基础：事件逐层冒泡总能被父元素捕获</span>
<span class="hljs-comment">// 只需在一个包装元素上链接一个句柄用于处理子元素发生的所有事件</span>

<span class="hljs-comment">// 每个事件的三个阶段： 捕获、到达目标、冒泡（IE 不支持捕获，实现托管只需要冒泡）</span>

<span class="hljs-comment">/*
    &lt;div&gt;
        &lt;ul id="menu"&gt;
            &lt;li&gt;&lt;a urn="#1"&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
*/</span>

<span class="hljs-comment">// 点击 a，事件先被 a 元素收到，然后沿 DOM 树冒泡，</span>
<span class="hljs-comment">// 接着分别被 li、ul、div 一直到达文档顶层，甚至 window 对象</span>

<span class="hljs-comment">// 在 menu 单元连接一个单击监听器，封装所有 click 事件：</span>
    document._getElementById(<span class="hljs-string">'menu'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span>
        e = e || window.event;
        <span class="hljs-keyword">var</span> target = e.target || e.srcElement;
        <span class="hljs-keyword">var</span> pageid = e.target || e.srcElement;
        <span class="hljs-keyword">if</span>(target.nodeName !== <span class="hljs-string">'A'</span>) { <span class="hljs-keyword">return</span> ;}
        hrefparts = target.href.split(<span class="hljs-string">'/'</span>);
        pageid = hrefparts[hrefparts.length-<span class="hljs-number">1</span>];
        pageid = pageid.replace(<span class="hljs-string">'.html'</span>, <span class="hljs-string">''</span>);
        ajaxRequest(<span class="hljs-string">'xhr.php?page='</span>+ id, updatePageContents);
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> e.preventDefault === <span class="hljs-string">'function'</span>) {
            e.preventDefault();
            e.stopPropagation();
        } <span class="hljs-keyword">else</span> {
            e.returnValue = <span class="hljs-literal">false</span>;
            e.cancelBubble = <span class="hljs-literal">true</span>;
        }
    }

<span class="hljs-comment">// 事件托管并不复杂，只需通过监听事件侦测事件是否从目标元素发出</span>
<span class="hljs-comment">// 这里有一些冗余的兼容代码，如果将其移入一个可重用的库中，可以简洁代码</span>
    <span class="hljs-comment">// 访问事件对象，判断事件源（目标）</span>
    <span class="hljs-comment">// 结束文档树上的冒泡（可选）</span>
    <span class="hljs-comment">// 阻止默认动作（可选，本例必选，因为任务是捕获而非转入这些链接）</span>


<span class="hljs-number">119.</span>使用定时器优化UI队列
<span class="hljs-comment">// setTimeout() setInterval() 都接受一样的参数：要执行的函数，以及等待时间</span>
<span class="hljs-comment">// 定时器与 UI 线程交互的方式有助于长运行脚本分解成较短的片段</span>

<span class="hljs-comment">// 250ms 后向 UI 队列插入一个 JS 任务来运行 greeting 函数</span>
<span class="hljs-comment">// 在此之前，所有其它 UI 更新和 JS 任务都在运行</span>
<span class="hljs-comment">// 注意：参二是指何时将任务添加到队列，而非那时代码将被执行，需等其它任务执行完毕</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeting</span><span class="hljs-params">()</span> {</span> alert(<span class="hljs-string">'Fuck'</span>) };
    setTimeout(greeting, <span class="hljs-number">250</span>);

<span class="hljs-comment">// 定时器的代码只有等创建它的函数运行完成之后才有可能被执行</span>
<span class="hljs-comment">// 250ms 是从调用 setTimeout 时开始计算的，而不是从整个函数运行结束时开始</span>
    <span class="hljs-keyword">var</span> btn = document.getElementById(<span class="hljs-string">'button'</span>);
    btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        oneMethod();
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            document.getElementById(<span class="hljs-string">'tip'</span>).style.color = <span class="hljs-string">'red'</span>;
        },<span class="hljs-number">250</span>);
    }

    <span class="hljs-comment">// 假设定时器延时变小，创建之后又调用了另一个函数，那么定时器可能在 onclick 之前加入队列</span>
    btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        oneMethod();
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
            document._getElementById(<span class="hljs-string">'notice'</span>).style.color = <span class="hljs-string">'red'</span>;
        },<span class="hljs-number">50</span>);
        anotherMethod();
    }

<span class="hljs-comment">// 定时器的创建会造成 UI 线程暂停，如同定时器从一个任务切换到下一个任务</span>
<span class="hljs-comment">// 定时器代码复位所有相关的浏览器限制，包括长运行脚本时间</span>
<span class="hljs-comment">// 调用栈也在定时器中复位为零，这一特性使得定时器成为长运行 JS 代码理想的跨浏览器解决方案</span>
<span class="hljs-comment">// 定时器延时往往不准确，几毫秒的误差，所以不可用于测量实际时间</span>

<span class="hljs-comment">// 常见的长运行脚本就是循环占用运行时间太长，尝试循环优化之后还不能缩减运行时间，那么首选定时器</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, len=items.length; i&lt;len; i++) { process(items[i]) }

    <span class="hljs-comment">// 导致循环结构运行时间过长的两个因素：process 的复杂程度、items 的大小</span>
    <span class="hljs-comment">// 用定时器取代循环的两个决定性因素：处理过程不需要同步处理、数据不需要按顺序处理</span>

<span class="hljs-comment">// 一种基本异步代码模式：</span>
    <span class="hljs-keyword">var</span> todo = items.concat();
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        process(todo.shift());
        <span class="hljs-keyword">if</span>(todo.length&gt;<span class="hljs-number">0</span>) {
            setTimeout(<span class="hljs-built_in">arguments</span>.callee, <span class="hljs-number">25</span>);
        } <span class="hljs-keyword">else</span> {
            callback(items);
        }
    }, <span class="hljs-number">25</span>);

    <span class="hljs-comment">// 这个模式的基本思想是创建一个原始数组的副本作为处理对象，第一次调用定时器处理队列中第一项</span>
    <span class="hljs-comment">// todo.shift() 返回第一项，然后将其从数组中删除，第一项的值作为参数传给 process</span>
    <span class="hljs-comment">// 接着检查是否还有更多项需要处理，如有则再启动一个运行相同的代码的定时器，</span>
    <span class="hljs-comment">// 所以将第一个参数传入 arguments.callee，此值指向当前运行中的匿名函数</span>
    <span class="hljs-comment">// 如没有内容要继续处理，将调用 callback 函数</span>

<span class="hljs-comment">// 异步代码模式与循环相比需要更多代码，可进行封装：</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processArray</span><span class="hljs-params">(items,process, callback)</span> {</span>
        <span class="hljs-keyword">var</span> todo = items.concat();
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            process(todo.shift());
            <span class="hljs-keyword">if</span>(todo.length &gt; <span class="hljs-number">0</span>) {
                setTimeout(<span class="hljs-built_in">arguments</span>.callee, <span class="hljs-number">25</span>);
            } <span class="hljs-keyword">else</span> {
                callback(items);
            }
        }, <span class="hljs-number">25</span>);
    }

    <span class="hljs-comment">// 函数以一种可重用的方式实现了先前的模板，且接受 3 个参数：</span>
    <span class="hljs-comment">// 待处理数组、对每个项调用的处理函数、处理结束时执行的回调函数</span>

    <span class="hljs-keyword">var</span> items = [<span class="hljs-number">123</span>, <span class="hljs-number">234</span>, <span class="hljs-number">345</span>, <span class="hljs-number">456</span>, <span class="hljs-number">567</span>];
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outputVal</span><span class="hljs-params">(val)</span> {</span>
        console.log(val);
    }
    processArray(items, outputVal, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        console.log(<span class="hljs-string">'Done!'</span>);
    });


<span class="hljs-comment">// 2017-02-24</span>
<span class="hljs-number">120.</span>使用定时器分解任务
<span class="hljs-comment">// 如果一个函数的运行时间较长，可以将其分解成一系列子任务</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saveDoc</span><span class="hljs-params">(id)</span> {</span>
        openDoc(id);
        writeTxt(id);
        closeDoc(id);
        updateUI(id);
    }

<span class="hljs-comment">// 使用数组模式处理：</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saveDoc</span><span class="hljs-params">(id)</span> {</span>
        <span class="hljs-keyword">var</span> tasks = [openDoc, writeTxt, closeDoc, updateUI];
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">var</span> task = tasks.shift();
            task(id);
            <span class="hljs-keyword">if</span>(tasks.length &gt;<span class="hljs-number">0</span> ) {
                setTimeout(<span class="hljs-built_in">arguments</span>.callee, <span class="hljs-number">25</span>);
            }
        }, <span class="hljs-number">25</span>);
    }

<span class="hljs-comment">// 封装：</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multistep</span><span class="hljs-params">(steps, args, callback)</span> {</span>
        <span class="hljs-keyword">var</span> tasks = steps.concat();
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">var</span> task = tasks.shift();
            task.apply(<span class="hljs-literal">null</span>, args || []);
            <span class="hljs-keyword">if</span>(tasks.length&gt;<span class="hljs-number">0</span>) {
                setTimeout(<span class="hljs-built_in">arguments</span>.callee, <span class="hljs-number">25</span>);
            } <span class="hljs-keyword">else</span> {
                callback();
            }
        }, <span class="hljs-number">25</span>);
    }

    <span class="hljs-comment">// 三个参数：执行函数数组、参数数组、回调函数</span>
    <span class="hljs-comment">// 参二必须是数组，创建时只包含一个id</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saveDoc</span><span class="hljs-params">(id)</span> {</span>
        <span class="hljs-keyword">var</span> tasks = [openDoc, writeTxt, closeDoc, updateUI];
        multistep(tasks, [id], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            console.log(<span class="hljs-string">'Done!'</span>);
        });
    }


<span class="hljs-number">121.</span>使用定时器限时运行代码
<span class="hljs-comment">// 有时每次只执行一个任务，效率不高</span>
<span class="hljs-comment">// 处理一个 1000 项的数组，每次 1ms，如果每个定时器处理一项，间隔 25ms，总耗时 26s</span>
<span class="hljs-comment">// 如果每次处理 50 个，间隔 25ms，总耗时 1.5s，且用户不会察觉页面阻塞</span>

<span class="hljs-comment">// 如果记住 JS 可连续运行的最大事件是 100ms，那可以进行优化，建议损益，不要超过 50ms</span>
<span class="hljs-comment">// 这是为了确保用户体验，通过 Date 对象跟踪运行时间，这是大多数 JS 分析工具采用的方式</span>

<span class="hljs-comment">// 每新创建的 Data 都以当前系统时间初始化，周期调用新 Data 对象并比值以获取代码运行时间</span>
<span class="hljs-comment">// 通过 + 将 Data 对象转换为一个数字，后续运算中就不必转换了</span>
    <span class="hljs-keyword">var</span> start = -<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>, stop;
    someLongProcess();
    stop = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
    <span class="hljs-keyword">if</span>(stop - start &lt; <span class="hljs-number">50</span>) {
        alert(<span class="hljs-string">'Just about right.'</span>);
    } <span class="hljs-keyword">else</span> {
        alert(<span class="hljs-string">'Takin too long.'</span>);
    }

<span class="hljs-comment">// 处理完每项后检测时间，数组中至少存放了一个项，后测试更合理</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timedProcessArray</span><span class="hljs-params">(items, process, callback)</span> {</span>
        <span class="hljs-keyword">var</span> todo = items.concat();
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
            <span class="hljs-keyword">var</span> start = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
            <span class="hljs-keyword">do</span> {
                process(todo.shift());
            } <span class="hljs-keyword">while</span> (todo.length &gt; <span class="hljs-number">0</span> &amp;&amp; (+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - start &lt; <span class="hljs-number">50</span>));
            <span class="hljs-keyword">if</span>( todo.length&gt;<span class="hljs-number">0</span>) {
                setTimeout(<span class="hljs-built_in">arguments</span>.callee, <span class="hljs-number">25</span>);
            } <span class="hljs-keyword">else</span> {
                callback(items);
            }
        }, <span class="hljs-number">25</span>);
    }


<span class="hljs-number">122.</span>推荐网页工人线程
<span class="hljs-comment">// 自 JS 诞生以来，还没有办法在浏览器 UI 线程之外运行代码，网页工人线程 API 出现了</span>
<span class="hljs-comment">// 它引入了一个接口，使代码运行而不占用浏览器 UI 线程的时间</span>
<span class="hljs-comment">// 作为最初 HTML5 的一部分，网页工人线程已经分离出去成为独立的规范（FF,C,S已实现）</span>

<span class="hljs-comment">// 这对网页来说是一个潜在的巨大性能提升，拥有独自运行 JS 的线程，不影响其它线程</span>
<span class="hljs-comment">// 但由于工人线程不绑定 UI 线程，将不能访问许多浏览器资源</span>
<span class="hljs-comment">// JS 和 UI 更新共享同一个进程的部分原因是二者互访频繁，互访失控将影响用户体验</span>
<span class="hljs-comment">// 修改 DOM 将导致界面出错，工人线程各有全局运行环境，只有 JS 特性的一个子集可用</span>

<span class="hljs-comment">// 网页工人线程组成部分：</span>
    <span class="hljs-comment">// 一个浏览器对象，包含四个属性：appName，appVersion，userAgent，platform</span>
    <span class="hljs-comment">// 一个 Location 对象：和 Window 对象一样，只是属性都是只读的</span>
    <span class="hljs-comment">// 一个 Self 对象指向全局工人线程对象</span>
    <span class="hljs-comment">// 一个 importScripts() 方法：使其可以加载外部 JS 文件</span>
    <span class="hljs-comment">// 所有 ECMAScript 核心对象</span>
    <span class="hljs-comment">// XMLHttpRequest 构造器</span>
    <span class="hljs-comment">// setTimeout() 和 setInterval() 方法</span>
    <span class="hljs-comment">// close() 方法：可以立即停止工人线程</span>

<span class="hljs-comment">// 因为是完全不同的运行环境，所以不能在 JS 代码中创建网页工人线程，需要单独创建一个 JS 文件</span>
    <span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">'code.js'</span>);

<span class="hljs-comment">// 代码一旦执行将为指定文件创建一个新线程和一个新的工人线程运行环境</span>
<span class="hljs-comment">// 此 JS 文件被异步下载，直到下载并运行完此文件之后才启动工人线程</span>

<span class="hljs-comment">// 工人线程和网页代码通过时间接口进行交互，网页通过 postMessage() 方法向线程传递数据</span>

<span class="hljs-comment">// onmessage 时间句柄用于接受信息，事件对象的 data 属性用于存放传入的数据</span>
    worker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>
        alert(event.data);
    }
    worker.postMessage(<span class="hljs-string">'Jisuowei'</span>);

<span class="hljs-comment">// 消息系统是页面和线程间唯一的交流途径，只有某些数据类型可以被传递（JS 基本类型）</span>
<span class="hljs-comment">// 有效数据被序列化，然后传入、传出工人线程，最后反序列化</span>
<span class="hljs-comment">// 当线程通过 importScripts() 方法加载外部 JS 文件时，接受 1+ URL 参数</span>
<span class="hljs-comment">// 线程以阻塞的方式调用 importScripts，直到所有文件加载完毕并执行后才退出</span>

<span class="hljs-comment">// 网页线程适合于那些纯数据的或与 UI 没有关系的长运行脚本</span>
<span class="hljs-comment">// 看起来用处不大啊，但在网页应用程序中通常有一些数据处理功能将受益于此</span>

<span class="hljs-comment">// 解析一个至少需要 500ms 的 JSON 字符串，显然时间太长</span>
<span class="hljs-comment">// 会导致不允许 JS 在客户端运行工人线程，会干扰用户体验</span>
<span class="hljs-comment">// 由于此任务难以分解成用于定时器的小段任务，所以工人线程成为理想的解决方案</span>

    <span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">'code.js'</span>);
    worker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>
        <span class="hljs-keyword">var</span> jsonData = event.data;
        evaluateData(jsonData);
    };
    worker.postMessage(jsonText);

    <span class="hljs-comment">// 工人线程负责代码解析</span>
    self.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>
        <span class="hljs-keyword">var</span> jsonText = event.data;
        <span class="hljs-keyword">var</span> jsonData = <span class="hljs-built_in">JSON</span>.parse(jsonText);
        self.postMessage(jsonData);
    }

<span class="hljs-comment">// 注意：即使 JSON.parse() 可能需要 500ms 或更多时间，也没必要添加更多代码来分解过程</span>
<span class="hljs-comment">// 由于此处理过程发生在一个独立的线程中，因此可以让它一直运行完而不干扰用户体验</span>


<span class="hljs-number">123.</span>比较IE和W3C事件流
<span class="hljs-comment">// 用户交互的效果是通过操作与响应来实现的，操作和响应之间需要事件作为桥梁</span>
<span class="hljs-comment">// 执行操作的是用户或浏览器，响应的是页面各种对象或浏览器自身</span>

<span class="hljs-comment">// IE 解决事件流的方案：冒泡（dubbed bubbling）</span>
<span class="hljs-comment">// 事件流按照从最特定的事件目标到最不特定的事件目标的顺序触发</span>
<span class="hljs-comment">// 在 DOM 树中从下往上传递，因而称为冒泡</span>

<span class="hljs-comment">// 各浏览器存在差异：</span>
    <span class="hljs-comment">// IE5.5-： p &gt; body &gt; document</span>
    <span class="hljs-comment">// IE6.0+： p &gt; body &gt; html &gt; document</span>
    <span class="hljs-comment">// Firefox：p &gt; body &gt; html &gt; document &gt; window</span>

<span class="hljs-comment">// 捕获事件流与冒泡事件流正好相反，从最不特定的开始，从上往下</span>

<span class="hljs-comment">// DOM2.0 进行了标准化：同时支持冒泡和捕获</span>
<span class="hljs-comment">// 规定捕获事件流先进行响应，然后响应冒泡事件流</span>
<span class="hljs-comment">// 这两种事件流会触及 DOM 中所有对象，起止都在 document 对象</span>
<span class="hljs-comment">// 不过大部分浏览器在支持 DOM 标准事件流时会影响 window 对象</span>

<span class="hljs-comment">// 默认地，事件使用冒泡事件流，开发者可以显式设置并使用捕获型事件流</span>
<span class="hljs-comment">// 方法是在注册事件时传入 useCapture 参数设置为 true</span>
<span class="hljs-comment">// 除了元素能响应事件外，DOM 标准还规定文本节点也可以响应，但 IE 不支持</span>


<span class="hljs-number">124.</span>设计鼠标拖放方案
<span class="hljs-comment">// onmousemove 是一个实时响应的事件类型（当光标位置发生变化：至少1px）</span>
<span class="hljs-comment">// 该时间相应的灵敏度主要参考光标移动速度，和浏览器跟踪更新的速度</span>

<span class="hljs-comment">// 针对鼠标拖放设计需要注意：元素定位、坐标概念、算法设计</span>
    <span class="hljs-keyword">var</span> box = document.getElementById(<span class="hljs-string">'box'</span>);
    box.style.position = <span class="hljs-string">'absolute'</span>;
    box.style.width = <span class="hljs-string">'100px'</span>;
    box.style.height = <span class="hljs-string">'100px'</span>;
    box.style.background = <span class="hljs-string">'red'</span>;
    <span class="hljs-comment">// 初始化变量，标准化事件对象</span>
    <span class="hljs-keyword">var</span> mx, my, ox, oy;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span><span class="hljs-params">(event)</span> {</span>
        <span class="hljs-keyword">if</span>(!event) {
            event = window.event;
            event.target = event.srcElement;
            event.layerX = event.offsetX;
            event.layerY = event.offsetY;
        }
        event.mx = event.pageX || event.clientX + document.body.scrollLeft;
        event.my = event.pageY || event.clientY + document.body.scrollTop;
        <span class="hljs-keyword">return</span> event;
    }
    <span class="hljs-comment">// 定义鼠标处理函数</span>
    document.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>
        event = e(event);
        o = event.target;
        ox = <span class="hljs-built_in">parseInt</span>(o.offsetLeft);
        oy = <span class="hljs-built_in">parseInt</span>(o.offsetTop);
        mx = event.mx;
        my = event.my;
        document.onmousemove = move;
        document.onmouseup = stop;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span><span class="hljs-params">(event)</span> {</span>
        event = e(event);
        o.style.left = ox + event.mx - mx + <span class="hljs-string">'px'</span>;
        o.style.top = oy + event.my - my + <span class="hljs-string">'px'</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stop</span><span class="hljs-params">(event)</span> {</span>
        event = e(event);
        ox = <span class="hljs-built_in">parseInt</span>(o.offsetLeft);
        oy = <span class="hljs-built_in">parseInt</span>(o.offsetTop);
        mx = event.mx;
        my = event.my;
        o = document.onmousemove = document.onmouseup = <span class="hljs-literal">null</span>;
    }


<span class="hljs-number">125.</span>设计鼠标指针定位方案
<span class="hljs-comment">// 当事件发生时，获取光标位置是很重要的操作，各浏览器差异：</span>
    <span class="hljs-comment">// clientX  浏览器窗口左上顶角</span>
    <span class="hljs-comment">// clientY  不兼容 Safari</span>

    <span class="hljs-comment">// offsetX  当前事件目标左上顶角</span>
    <span class="hljs-comment">// offsetY  不兼容 Firefox</span>

    <span class="hljs-comment">// pageX    document对象左上顶角</span>
    <span class="hljs-comment">// pageY    不兼容 IE</span>

    <span class="hljs-comment">// screenX  计算机屏幕左上顶角</span>
    <span class="hljs-comment">// screenY  全部兼容</span>

    <span class="hljs-comment">// layerX   最近的绝对定位的父元素的左上顶角（没有则是 document对象）</span>
    <span class="hljs-comment">// layerY   只有 Firefox 和 safari</span>

<span class="hljs-comment">// 优选全部兼容的 screen 来设计：</span>
    <span class="hljs-keyword">var</span> pos = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, x, event)</span> {</span>
        <span class="hljs-keyword">var</span> posX = <span class="hljs-number">0</span>, poxY = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> event = event || window.event;
        <span class="hljs-keyword">if</span>(event.pageX || event.pageY) {
            posX = event.pageX;
            posY = event.pageY;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(event.clientX || event.clientY) {
            posX = event.clientX 
                + document.documentElement.scrollLeft 
                + document.body.scrollLeft;
            posY = event.clientY
                + document.documentElement.scrollTop
                + document.body.scrollTop;
        }
        o.style.position = <span class="hljs-string">'absolute'</span>;
        o.style.top = (posY + y) + <span class="hljs-string">'px'</span>;
        o.style.left = (posX + x) + <span class="hljs-string">'px'</span>;
    }

    <span class="hljs-comment">// 为 document 对象注册鼠标移动事件处理函数，并传入鼠标定位封装函数</span>
    <span class="hljs-comment">// 非 IE 浏览器要通过参数形式传递事件对象</span>


<span class="hljs-number">126.</span>小心在元素内定位鼠标指针
<span class="hljs-comment">// 要获取光标在元素内的坐标，目前还没有更稳妥的解决方案：</span>
    <span class="hljs-keyword">var</span> event = event || window.event;
    <span class="hljs-keyword">if</span>(event.offsetX || event.offsetY) {
        x = event.offsetX;
        y = event.offsetY;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(event.layerX || event.layerY) {  <span class="hljs-comment">// 兼容 FF</span>
        x = event.layerX;
        x = event.layerY;
    }

<span class="hljs-comment">// 但是 layerX 和 layerY 属性以绝对定位的父元素为参考物，如果没有这样的父元素，</span>
<span class="hljs-comment">// 则以 document 对象为参照物，为此可以通过脚本动态或手动添加一个绝对定位的父元素</span>
    <span class="hljs-keyword">var</span> t = document.getElementById(<span class="hljs-string">'text'</span>);
    <span class="hljs-keyword">var</span> div1 = document.getElementById(<span class="hljs-string">'div1'</span>);
    div1.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>
        <span class="hljs-keyword">var</span> event = event || window.event;
        <span class="hljs-keyword">if</span>(event.offsetX || event.offsetY) {
            t.value = event.offsetX +<span class="hljs-string">' '</span>+ event.offsetY;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(event.layerX || event.layerY) {
            t.value = (event.layerX-<span class="hljs-number">1</span>) +<span class="hljs-string">' '</span>+ (event.layerY-<span class="hljs-number">1</span>);
        }
    }

    <span class="hljs-comment">// 这种做法能解决在元素内部定位鼠标指针问题，但包裹可能会造成布局问题</span>
    <span class="hljs-comment">// 由于浏览器的不兼容，鼠标定位一直是一个难题，在 JS 开发中，</span>
    <span class="hljs-comment">// 应避免将鼠标定位作为事件触发条件（计算光标的坐标是否存在于元素内部）</span>
    <span class="hljs-comment">// 而应通过元素的 mouseover 事件、焦点事件来触发</span>


<span class="hljs-number">127.</span>妥善使用DOMContentLoaded事件
<span class="hljs-comment">// 在传统事件模型中，load 是页面最早被触发的事件，但用它初始化页面有一个问题：</span>
<span class="hljs-comment">// 当页面中包含很大的文件时，load 需要等到所有文件载入之后才会触发</span>
<span class="hljs-comment">// 这时可以考虑使用 DOMContentLoaded 事件：在 DOM 加载完毕时触发的，比 load 早</span>
<span class="hljs-comment">// 目前只有 FF 和 O 支持此事件</span>
    window.onload = f1;
    <span class="hljs-keyword">if</span>(document.addEventListener) {
        document.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, f, <span class="hljs-literal">false</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> {</span>alert(<span class="hljs-string">'DOMContentLoaded'</span>)};
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> {</span>alert(<span class="hljs-string">'load'</span>)};

<span class="hljs-comment">// 兼容IE：</span>
    <span class="hljs-keyword">if</span>(window.ActiveXObject) {
        document.write(
            <span class="hljs-string">'&lt;script id=id_onload defer src=javascript:void(0) &gt;&lt;\/script&gt;'</span>
        );
        document.getElementById(<span class="hljs-string">'ie_onload'</span>).onreadychange = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.readyState == <span class="hljs-string">'complete'</span>) {
                <span class="hljs-keyword">this</span>.onreadychange = <span class="hljs-literal">null</span>;
                f();
            }
        }
    }

    <span class="hljs-comment">// defer 表示延期，可以让脚本在整个页面加载完成之后再解析</span>
    <span class="hljs-comment">// 这对只包含事件触发的脚本来说可以提高整个页面的加载速度</span>
    <span class="hljs-comment">// 与 src 属性联合使用，还可以使这些脚本在后台被下载，前台正常显示</span>
    <span class="hljs-comment">// 目前只有 IE 支持 defer 属性</span>

<span class="hljs-comment">// 兼容 Safari：</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/WebKit/i</span>.test(navigator.userAgent)) {
        <span class="hljs-keyword">var</span> _timer = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
            <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/loaded|complete/</span>.test(document.readyState)) {
                clearInterval(_timer);
                f();
            }
        }, <span class="hljs-number">10</span>);
    }


<span class="hljs-number">128.</span>推荐使用beforeunload事件
<span class="hljs-comment">// unload 表示卸载；这个事件在从当前浏览器窗口内移动文档的位置时触发</span>
<span class="hljs-comment">// 如：超链接、前进、后退从一个页面到另一个页面，或者关闭浏览器时</span>

<span class="hljs-comment">// 在 unload 事件中无法有效阻止默认行为，因为该事件结束后，页面不复存在</span>
<span class="hljs-comment">// 在窗口关闭或离开页面前只有很短的时间来执行事件处理函数，因此不建议使用该事件类型</span>
<span class="hljs-comment">// 使用的最佳方式是取消该页面的对象引用</span>

<span class="hljs-comment">// beforeunload 与 unload 功能相似，但更人性化，会弹出 promt</span>
    window.onbeforeunload = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'数据未保存!'</span>;
    }

<span class="hljs-comment">// beforeunload 的返回值可以为任意类型，IE 和 S 能通过 toString() 转换并显示在对话框</span>
<span class="hljs-comment">// 如果没有返回值则不弹出，此时效果与 unload 相同。O 不支持该事件</span>


<span class="hljs-number">129.</span>自定义事件
<span class="hljs-comment">// 事件是一种称作观察者的设计模式，是一种创建松散耦合代码的技术</span>
<span class="hljs-comment">// 对象可以发布事件，表示该对象声明周期中某个时刻到了，</span>
<span class="hljs-comment">// 其它对象可以观察该对象，等待时刻到来并通过运行代码来响应</span>
<span class="hljs-comment">// 观察者模式组成：主体、观察者</span>
    <span class="hljs-comment">// 主体负责发布事件，同时观察者通过订阅这些事件来观察主体</span>
    <span class="hljs-comment">// 主体并不知道观察者的任何事情，它可以独自存在并正常运作，即使观察者不在</span>

<span class="hljs-comment">// 自定义事件就是对已有事件进行包装，依赖已有的键盘、鼠标、HTML来执行</span>
<span class="hljs-comment">// 自定义事件内部有一个事件存储器，就轮询执行添加到该类型下的函数</span>
<span class="hljs-comment">// 自定义事件隐含的作用是创建一个管理事件对象，让其它对象能够监听那些事件</span>
<span class="hljs-comment">// 基于自定义事件的原理，可以想象很多时候是用于实现“订阅-发布-接收”性质的功能</span>

<span class="hljs-comment">// 基本模式：</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EventTarget</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">this</span>.handlers = [];
    }
    EventTarget.prototype = {
        constructor: EventTarget,
        addHandler: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(type, handler)</span> {</span>
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.handlers[type] == <span class="hljs-string">'undefined'</span>) {
                <span class="hljs-keyword">this</span>.handlers[type] = [];
            }
            <span class="hljs-keyword">this</span>.handlers[type].push(handler);
        },
        fire: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>
            <span class="hljs-keyword">if</span>(!event.target) {
                event.target = <span class="hljs-keyword">this</span>;
            }
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.handlers[event.type] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {
                <span class="hljs-keyword">var</span> handlers = <span class="hljs-keyword">this</span>.handlers[event.type];
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;handlers.length; i++) {
                    handlers[i](event);
                }
            }
        },
        removeHandler: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(type, handler)</span> {</span>
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.handlers[type] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {
                <span class="hljs-keyword">var</span> handlers = <span class="hljs-keyword">this</span>.handlers[type];
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;handlers.length; i++) {
                    <span class="hljs-keyword">if</span>(handlers[i] === handler) { <span class="hljs-keyword">break</span>; }
                }
                handlers.splice(i, <span class="hljs-number">1</span>);
            }
        }
    };

<span class="hljs-comment">// 使用 EventTarget 类型定义事件：</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleMsg</span><span class="hljs-params">(event)</span> {</span>
        alert(<span class="hljs-string">'Msg: '</span>+ event.message);
    }
    <span class="hljs-comment">// 创建一个新对象</span>
    <span class="hljs-keyword">var</span> target = <span class="hljs-keyword">new</span> EventTarget();
    <span class="hljs-comment">// 添加一个事件处理程序</span>
    target.addHandler(<span class="hljs-string">'message'</span>, handleMsg);
    <span class="hljs-comment">// 触发事件</span>
    target.fire({
        type: <span class="hljs-string">'message'</span>,
        message: <span class="hljs-string">'Fuck you'</span>
    });
    <span class="hljs-comment">// 删除事件处理程序</span>
    target.removeHandler(<span class="hljs-string">'message'</span>, handleMsg);

<span class="hljs-comment">// 使用实例：</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span><span class="hljs-params">(name, age)</span> {</span>
        eventTarget.call(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }
    inheritPrototype(Person, EventTarget);
    Person.ptototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(message)</span> {</span>
        <span class="hljs-keyword">this</span>.fire({
            type: <span class="hljs-string">'message'</span>,
            message: <span class="hljs-string">'msg'</span>
        });
    };
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleMsg</span><span class="hljs-params">(event)</span> {</span>
        alert(event.target.name +<span class="hljs-string">'says: '</span>+ event.message);
    }
    <span class="hljs-comment">// 创建新 Person</span>
    <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Chisw'</span>, <span class="hljs-number">26</span>);
    <span class="hljs-comment">// 添加一个事件处理程序</span>
    Person.addHandler(<span class="hljs-string">'message'</span>, handleMsg);
    <span class="hljs-comment">// 在该对象上调用一个方法触发消息事件</span>
    person.say(<span class="hljs-string">'Go home now'</span>);


<span class="hljs-number">130.</span>从CSS样式表中抽取元素尺寸
<span class="hljs-comment">// style 是一个集合对象，内部包含很多 CSS 脚本属性</span>
<span class="hljs-comment">// JS 中读写 CSS 属性时必须包含单位，且都以字符串的形式往返</span>
<span class="hljs-comment">// 这种方式获取的信息往往是不准确的，因为 style 属性中并不包括默认值</span>
<span class="hljs-comment">// DOM 标准在读取 CSS 属性值时比较特殊：使用连字符</span>

<span class="hljs-comment">// 兼容获取</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span><span class="hljs-params">(e, n)</span> {</span>
        <span class="hljs-keyword">if</span>(e.style[n]) {
            <span class="hljs-keyword">return</span> e.style[n];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e.currentStyle) {
            <span class="hljs-keyword">return</span> e.currentStyle[n];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(document.defaultView &amp;&amp; document.defaultView.getComputedStyle) {
            n = n.replace(<span class="hljs-regexp">/([A-Z])/g</span>, <span class="hljs-string">'-$1'</span>);
            n = n.toLowerCase();
            <span class="hljs-keyword">var</span> s = document.defaultView.getComputedStyle(e, <span class="hljs-literal">null</span>);
            <span class="hljs-keyword">if</span>(s) {
                <span class="hljs-keyword">return</span> s.getPropertyValue(n);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
        }
    }


<span class="hljs-number">131.</span>慎重使用offsetWidth和offsetHeight
<span class="hljs-comment">// 二者分别获取元素在页面中所占据的宽度、高度</span>
<span class="hljs-comment">// IE 的“怪异模式”会有误差，DOCTYPE 没有明确定义</span>
<span class="hljs-comment">// display:none 时都为 0</span>


<span class="hljs-number">132.</span>正确计算区域大小
<span class="hljs-comment">// 元素尺寸相关属性</span>
    <span class="hljs-comment">// clientWidth    可视部分</span>
    <span class="hljs-comment">// clientHeight   width|height + padding</span>

    <span class="hljs-comment">// offsetWidth    占据部分</span>
    <span class="hljs-comment">// offsetHeight   width|height + padding + border</span>

    <span class="hljs-comment">// scrollWidth    overflow:visible 时元素可滚动部分</span>
    <span class="hljs-comment">// scrollHeight   默认等于 client，大于时显示滚动条</span>

<span class="hljs-comment">// 各浏览器解析 scroll 差异</span>
    <span class="hljs-comment">// IE    padding-top + content + padding-bottom</span>
    <span class="hljs-comment">// FF    padding-top + content</span>
    <span class="hljs-comment">// S     padding-top + content</span>
    <span class="hljs-comment">// O     content + padding-bottom</span>

<span class="hljs-comment">// 各浏览器解析 client 差异</span>
    <span class="hljs-comment">// IE   padding-top + content + padding-bottom</span>
    <span class="hljs-comment">// FF   border-top-width + padding-top + content + padding-bottom + border-bottom-width</span>
    <span class="hljs-comment">// S    padding-top + content + padding-bottom</span>
    <span class="hljs-comment">// O    padding-top + content + padding-bottom</span>


<span class="hljs-number">133.</span>谨慎计算滚动区域大小
<span class="hljs-comment">// scrollLeft 和 scrollTop 属性比较特殊</span>
<span class="hljs-comment">// 利用它们可以定义当拖动滚动条时移除可视区域外的宽度和高度</span>
<span class="hljs-comment">// 也可以利用这两个属性设定滚动条的位置</span>
<span class="hljs-comment">// 也可以使用它们获取当前滚动区域内容</span>


<span class="hljs-number">134.</span>避免计算窗口大小
<span class="hljs-comment">// 对于浏览器窗口来说，通过获取&lt;html&gt;标签的 client 属性就可以得到浏览器窗口的可视宽度和高度</span>
    <span class="hljs-keyword">var</span> w = document.documentElement.clientWidth;
    <span class="hljs-keyword">var</span> h = document.documentElement.clientHeight;

<span class="hljs-comment">// 不过在 IE6.0- 浏览器中（即在IE浏览器的“怪异”解析模式下），body 是最顶层的可视元素</span>
<span class="hljs-comment">// 而 html 元素保持隐藏，因此只有通过&lt;body&gt;标签的 client 属性才可以得到浏览器窗口的可视宽度和高度，</span>
    <span class="hljs-keyword">var</span> w = document.body.clientWidth;
    <span class="hljs-keyword">var</span> h = document.body.clientHeight;

<span class="hljs-comment">// 通用：</span>
    <span class="hljs-keyword">var</span> w = document.documentElement.clientWidth  || document.body.clientWidth;
    <span class="hljs-keyword">var</span> h = document.documentElement.clientHeight || document.body.clientHeight;

<span class="hljs-comment">// 如果窗口包含内容超出了窗口可视区域，那么应该使用 scroll 属性来获取窗口的实际宽度和高度</span>
<span class="hljs-comment">// 不过对于 document.documentElement 和 document.body 来说，不同浏览器对于它们的支持略有差异</span>


<span class="hljs-number">135.</span>正确获取绝对位置
<span class="hljs-comment">// 任何元素都拥有 offset 属性，它们用于描述元素的偏移位置</span>
<span class="hljs-comment">// IE 会参照父元素为对象进行偏移，而支持 DOM 标准的浏览器会参照最近非静态定位元素为对象进行偏移</span>

<span class="hljs-comment">// 任何浏览器 offsetParent 总能自动识别参照对象，不用担心在不同浏览器中具体指代什么元素</span>
<span class="hljs-comment">// 获取指定元素距离窗口左上角的偏移坐标</span>
<span class="hljs-comment">// 参数：e表示获取位置的元素</span>
<span class="hljs-comment">// 返回值：返回对象直接量，其中属性x表示x轴偏移距离，属性y表示y轴偏移距离</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getW</span><span class="hljs-params">(e)</span> {</span>
        <span class="hljs-keyword">var</span> x = y = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(e.offsetParent){
            x += e.offsetLeft;
            y += e.offsetTop;
            e = e.offsetParent;
        }
        <span class="hljs-keyword">return</span> { <span class="hljs-string">"x"</span> : x, <span class="hljs-string">"y"</span> : y };
    }

    <span class="hljs-comment">// 由于 body、html 没有offsetParent，当迭代到 body 时，</span>
    <span class="hljs-comment">// 会自动停止并计算出当前元素距离窗口左上角的坐标距离</span>

<span class="hljs-comment">// 注意：不要为包含元素定义边框，因为不同浏览器对边框的处理方式不同</span>
<span class="hljs-comment">// IE 会忽略所有包含元素的边框，因为所有元素都是参照对象，并且以参照对象的边框内壁作为边线进行计算</span>
<span class="hljs-comment">// FF、S 会把静态元素的边框作为实际距离进行计算，因为对于它们来说，静态元素不作为参照对象</span>
<span class="hljs-comment">// 而对于 O 来说，由于它以非静态元素边框的外壁作为边线进行计算，所以该浏览器所获取的值又有所不同</span>
<span class="hljs-comment">// 如果不为所有包含元素定义边框，那么可以避免不同浏览器解析的分歧，最终实现返回相同的距离</span>


<span class="hljs-number">136.</span>正确获取相对位置
<span class="hljs-comment">// 在复杂的嵌套结构中，仅仅获取元素相对于浏览器窗口的位置并没有多大利用价值，</span>
<span class="hljs-comment">// 因为定位元素是根据最近的上级非静态元素进行的</span>
<span class="hljs-comment">// 同时对于静态元素来说，它是根据父元素的位置来决定自己的显示位置的</span>
<span class="hljs-comment">// 要获取相对父级元素的位置，不能简单地读取CSS样式的left和top属性，</span>
<span class="hljs-comment">// 因为这两个属性值是相对最近的上级非静态元素来说的</span>
<span class="hljs-comment">// 可以调用 JS188-135 定义的 getW() 分别获取当前元素和父元素距离窗口的距离，然后求差即可</span>
    <span class="hljs-comment">// 获取指定元素距离父元素左上角的偏移坐标</span>
    <span class="hljs-comment">// 参数：e表示获取位置的元素</span>
    <span class="hljs-comment">// 返回值：返回对象直接量，其中属性x表示x轴偏移距离，属性y表示y轴偏移距离</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getP</span><span class="hljs-params">(e)</span>{</span>
        <span class="hljs-keyword">if</span>(e.parentNode == e.offsetParent){
            <span class="hljs-keyword">var</span> x = e.offsetLeft;
            <span class="hljs-keyword">var</span> y = e.offsetTop ;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> o = getW(e);
            <span class="hljs-keyword">var</span> p = getW(e.parentNode);
            <span class="hljs-keyword">var</span> x = o.x - p.x;
             <span class="hljs-keyword">var</span> y = o.y - p.y;
        }
        <span class="hljs-keyword">return</span> { <span class="hljs-string">"x"</span> : x, <span class="hljs-string">"y"</span> : y };
    }

    <span class="hljs-keyword">var</span> box = document.getElementById(<span class="hljs-string">"box"</span>);
    <span class="hljs-keyword">var</span> o = getP(box);
    alert(o.x);
    alert(o.y);


    <span class="hljs-comment">// 获取指定元素距离包含块元素左上角的偏移坐标</span>
    <span class="hljs-comment">// 参数：e表示获取位置的元素</span>
    <span class="hljs-comment">// 返回值：返回对象直接量，其中属性x表示x轴偏移距离，属性y表示y轴偏移距离</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getB</span><span class="hljs-params">(e)</span>{</span>
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"x"</span> : (<span class="hljs-built_in">parseInt</span>(getStyle(e, <span class="hljs-string">"left"</span>)) || <span class="hljs-number">0</span>),
            <span class="hljs-string">"y"</span> : (<span class="hljs-built_in">parseInt</span>(getStyle(e, <span class="hljs-string">"top"</span>)) || <span class="hljs-number">0</span>)
        };
    }

</code></pre>